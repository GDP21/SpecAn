<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>scbm_api.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>scbm_api.h File Reference</h1>Serial Control Bus Master API.  
<a href="#_details">More...</a>
<p>

<p>
<a href="scbm__api_8h-source.html">Go to the source code of this file.</a><h2>Data Structures</h2>
<ul>
<li>struct <a class="el" href="structscbm__settings__t.html">scbm_settings_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the SCBM port settings.  <a href="structscbm__settings__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structscbm__callback__t.html">scbm_callback_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the SCBM Callback type.  <a href="structscbm__callback__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structscbm__io__block__t.html">scbm_io_block_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the SCBM I/O Block type required for asynchronous operation.  <a href="structscbm__io__block__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structscbm__async__t.html">scbm_async_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the asynchronous I/O descriptor type.  <a href="structscbm__async__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structscbm__port__t.html">scbm_port_t</a>
<dl class="el"><dd class="mdescRight">This structure describes a SCB master logical object.  <a href="structscbm__port__t.html#_details">More...</a><br></dl></ul>
<h2>Defines</h2>
<ul>
<li><a class="anchor" name="f951502c4b9c83d0bbff4cb76277e434"></a><!-- doxytag: member="scbm_api.h::__SCBM_API_H__" ref="f951502c4b9c83d0bbff4cb76277e434" args="" -->
#define <b>__SCBM_API_H__</b>
<li>#define <a class="el" href="scbm__api_8h.html#c4d6ec6a3a356e44ec951c07b203ed65">SCBM_INF_TIMEOUT</a>&nbsp;&nbsp;&nbsp;(-1)
<li>#define <a class="el" href="scbm__api_8h.html#d82d13592e382c23387556cddc33a124">SCBM_ADDR_UPPER_LIMIT</a>&nbsp;&nbsp;&nbsp;(0x3FF)
<li>#define <a class="el" href="scbm__api_8h.html#55f30bd2bb6576cfa5e887c36d684cd0">SCBM_ASYNC_GET_RESULT</a>(async)&nbsp;&nbsp;&nbsp;{ (async)-&gt;forget = 0; }
<li>#define <a class="el" href="scbm__api_8h.html#ae2be8dee19f546ebf7ed96b9dece2c8">SCBM_ASYNC_FORGET</a>(async)
<li>#define <a class="el" href="scbm__api_8h.html#6e1877de9a62c335d69acd23bf9847ee">SCBM_ASYNC_CALLBACK</a>(async, routine, context)
<li><a class="anchor" name="46a0f02ba45a70957d7831af17a09908"></a><!-- doxytag: member="scbm_api.h::INTERNAL_SCBM_MEM_SIZE" ref="46a0f02ba45a70957d7831af17a09908" args="" -->
#define <b>INTERNAL_SCBM_MEM_SIZE</b>&nbsp;&nbsp;&nbsp;(70)
</ul>
<h2>Typedefs</h2>
<ul>
<li><a class="anchor" name="6816fdc466181859f309854d0349e3f6"></a><!-- doxytag: member="scbm_api.h::SCBM_eErrorStatus" ref="6816fdc466181859f309854d0349e3f6" args="" -->
typedef enum scbm_err_status <b>SCBM_eErrorStatus</b>
<li><a class="anchor" name="1d8005d36ccd6527c47c559e6e767e04"></a><!-- doxytag: member="scbm_api.h::SCBM_SETTINGS_T" ref="1d8005d36ccd6527c47c559e6e767e04" args="" -->
typedef struct <a class="el" href="structscbm__settings__t.html">scbm_settings_t</a> <a class="el" href="scbm__api_8h.html#1d8005d36ccd6527c47c559e6e767e04">SCBM_SETTINGS_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the SCBM port settings. <br></dl><li>typedef void <a class="el" href="scbm__api_8h.html#89cab02f4f13a1ce35e72bfcbc3ec3d2">SCBM_CALLBACKROUTINE_T</a> (void *context, signed long read, unsigned long address, unsigned char *buffer, unsigned long num_bytes_transferred, unsigned long status)
<dl class="el"><dd class="mdescRight">This type defines the Callback Routine used by the SCBM device driver in the asynchronous transfer mode.  <a href="#89cab02f4f13a1ce35e72bfcbc3ec3d2"></a><br></dl><li><a class="anchor" name="da0017e610b10b0f423e931519e3eb58"></a><!-- doxytag: member="scbm_api.h::SCBM_CALLBACK_T" ref="da0017e610b10b0f423e931519e3eb58" args="" -->
typedef struct <a class="el" href="structscbm__callback__t.html">scbm_callback_t</a> <a class="el" href="scbm__api_8h.html#da0017e610b10b0f423e931519e3eb58">SCBM_CALLBACK_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the SCBM Callback type. <br></dl><li><a class="anchor" name="9cd87b80847e4a7f197cfdc32076c667"></a><!-- doxytag: member="scbm_api.h::SCBM_IO_BLOCK_T" ref="9cd87b80847e4a7f197cfdc32076c667" args="" -->
typedef struct <a class="el" href="structscbm__io__block__t.html">scbm_io_block_t</a> <a class="el" href="scbm__api_8h.html#9cd87b80847e4a7f197cfdc32076c667">SCBM_IO_BLOCK_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the SCBM I/O Block type required for asynchronous operation. <br></dl><li><a class="anchor" name="73c0c14fd4e59cb73d1ed878210d48b2"></a><!-- doxytag: member="scbm_api.h::SCBM_ASYNC_T" ref="73c0c14fd4e59cb73d1ed878210d48b2" args="" -->
typedef struct <a class="el" href="structscbm__async__t.html">scbm_async_t</a> <a class="el" href="scbm__api_8h.html#73c0c14fd4e59cb73d1ed878210d48b2">SCBM_ASYNC_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the asynchronous I/O descriptor type. <br></dl><li>typedef struct <a class="el" href="structscbm__port__t.html">scbm_port_t</a> <a class="el" href="scbm__api_8h.html#feeb88107d056cc518c0a9d00c9c7713">SCBM_PORT_T</a>
<dl class="el"><dd class="mdescRight">This structure describes a SCB master logical object.  <a href="#feeb88107d056cc518c0a9d00c9c7713"></a><br></dl></ul>
<h2>Enumerations</h2>
<ul>
<li>enum <a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d">SCBM_STATUS_CODES</a> { <br>
&nbsp;&nbsp;<a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232df7459b895b168b03a2db55f679e5ce78">SCBM_STATUS_SUCCESS</a> =  0, 
<a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d1cbfa1e4cfb387f4e1cbb26dfb7a7a16">SCBM_STATUS_INVALID_PORT</a>, 
<a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d497c3588084c78791e6eedd01ae30b9e">SCBM_STATUS_CANCEL</a>, 
<a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d1d3dcaaec298c7c52956b33b4f8eb5bd">SCBM_STATUS_TIMEOUT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d7799938cd0edc5499d470eacee3bc0a8">SCBM_STATUS_WOULD_BLOCK</a>
<br>
 }
<li>enum <b>scbm_err_status</b> { <br>
&nbsp;&nbsp;<b>SCBM_ERR_NONE</b>, 
<b>SCBM_ERR_ADDRESS_ERROR</b>, 
<b>SCBM_ERR_TRANSFER_ERROR</b>, 
<b>SCBM_ERR_BUS_ERROR</b>, 
<br>
&nbsp;&nbsp;<b>SCBM_ERR_BUS_INACTIVE</b>
<br>
 }
</ul>
<h2>Functions</h2>
<ul>
<li><a class="anchor" name="78a5ba9f28e2625f93418b9312db2e39"></a><!-- doxytag: member="scbm_api.h::SCBMDefine" ref="78a5ba9f28e2625f93418b9312db2e39" args="(ioblock_sBlockDescriptor *psBlockDescriptor)" -->
img_void <b>SCBMDefine</b> (<a class="el" href="structioblock__sBlockDescriptorTag.html">ioblock_sBlockDescriptor</a> *psBlockDescriptor)
<li>unsigned long <a class="el" href="scbm__api_8h.html#b4eb59bbace63c8bc6ba363bd2c08ae8">SCBMInit</a> (<a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *port, <a class="el" href="structscbm__settings__t.html">SCBM_SETTINGS_T</a> *port_settings, <a class="el" href="structscbm__io__block__t.html">SCBM_IO_BLOCK_T</a> *io_blocks, unsigned long num_io_blocks)
<li>unsigned long <a class="el" href="scbm__api_8h.html#60accdf8c6b6b86d2c77b77733003d82">SCBMDeinit</a> (<a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *port)
<li>unsigned long <a class="el" href="scbm__api_8h.html#d9363b9364834fc86a51e5aaf98c074a">SCBMRead</a> (<a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *port, unsigned long address, unsigned char *buffer, unsigned long num_bytes_to_read, unsigned long *num_bytes_read, <a class="el" href="structscbm__async__t.html">SCBM_ASYNC_T</a> *async, long timeout)
<li>unsigned long <a class="el" href="scbm__api_8h.html#801e978c1173476cd83302fe1e9cd45b">SCBMWrite</a> (<a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *port, unsigned long address, unsigned char *buffer, unsigned long num_bytes_to_write, unsigned long *num_bytes_written, <a class="el" href="structscbm__async__t.html">SCBM_ASYNC_T</a> *async, long timeout)
<li>unsigned long <a class="el" href="scbm__api_8h.html#4788388eb4c905bd56bc075602532113">SCBMGetResult</a> (<a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *port, signed long *read, unsigned long *address, unsigned long *num_bytes_transferred, signed long block, long timeout)
<li>void <a class="el" href="scbm__api_8h.html#63145a5032894485f97bfbf3119bb066">SCBMCancel</a> (<a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *port)
<li><a class="anchor" name="3e58a26e0f9a01ec7041cbe9ada56589"></a><!-- doxytag: member="scbm_api.h::SCBMGetErrorStatus" ref="3e58a26e0f9a01ec7041cbe9ada56589" args="(const SCBM_PORT_T *port)" -->
unsigned long <b>SCBMGetErrorStatus</b> (const <a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *port)
</ul>
<h2>Variables</h2>
<ul>
<li><a class="anchor" name="3f93e44cca12994ec38c712cad55984d"></a><!-- doxytag: member="scbm_api.h::IMG_asSCBBlock" ref="3f93e44cca12994ec38c712cad55984d" args="[]" -->
<a class="el" href="structioblock__sBlockDescriptorTag.html">ioblock_sBlockDescriptor</a> <b>IMG_asSCBBlock</b> []
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains the header file information for the Serial Control Bus Master (SCBM) API.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Imagination Technologies</dd></dl>
<b>Copyright 2006 by Imagination Technologies Limited.</b><br>
 All rights reserved. No part of this software, either material or conceptual may be copied or distributed, transmitted, transcribed, stored in a retrieval system or translated into any human or computer language in any form by any means, electronic, mechanical, manual or other-wise, or disclosed to the third parties without the express written permission of Imagination Technologies Limited, Home Park Estate, Kings Langley, Hertfordshire, WD4 8LZ, U.K. <hr><h2>Define Documentation</h2>
<a class="anchor" name="c4d6ec6a3a356e44ec951c07b203ed65"></a><!-- doxytag: member="scbm_api.h::SCBM_INF_TIMEOUT" ref="c4d6ec6a3a356e44ec951c07b203ed65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCBM_INF_TIMEOUT&nbsp;&nbsp;&nbsp;(-1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Infinite wait (do not time out). 
</div>
</div><p>
<a class="anchor" name="d82d13592e382c23387556cddc33a124"></a><!-- doxytag: member="scbm_api.h::SCBM_ADDR_UPPER_LIMIT" ref="d82d13592e382c23387556cddc33a124" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCBM_ADDR_UPPER_LIMIT&nbsp;&nbsp;&nbsp;(0x3FF)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Upper slave address limit 
</div>
</div><p>
<a class="anchor" name="55f30bd2bb6576cfa5e887c36d684cd0"></a><!-- doxytag: member="scbm_api.h::SCBM_ASYNC_GET_RESULT" ref="55f30bd2bb6576cfa5e887c36d684cd0" args="(async)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCBM_ASYNC_GET_RESULT          </td>
          <td>(</td>
          <td class="paramtype">async&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{ (async)-&gt;forget = 0; }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Async descriptor helper macro used to get result of async operation. 
</div>
</div><p>
<a class="anchor" name="ae2be8dee19f546ebf7ed96b9dece2c8"></a><!-- doxytag: member="scbm_api.h::SCBM_ASYNC_FORGET" ref="ae2be8dee19f546ebf7ed96b9dece2c8" args="(async)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCBM_ASYNC_FORGET          </td>
          <td>(</td>
          <td class="paramtype">async&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ (async)-&gt;forget = 1; \
      (async)-&gt;callback_routine = NULL; }
</pre></div>Async descriptor helper macro used to ignore result of async operation. 
</div>
</div><p>
<a class="anchor" name="6e1877de9a62c335d69acd23bf9847ee"></a><!-- doxytag: member="scbm_api.h::SCBM_ASYNC_CALLBACK" ref="6e1877de9a62c335d69acd23bf9847ee" args="(async, routine, context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCBM_ASYNC_CALLBACK          </td>
          <td>(</td>
          <td class="paramtype">async,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">routine,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ (async)-&gt;forget = 1; \
      (async)-&gt;callback_routine = routine; \
      (async)-&gt;callback_context = context; }
</pre></div>Async descriptor helper macro used to register a callback routine to collect the result of an async operation. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="89cab02f4f13a1ce35e72bfcbc3ec3d2"></a><!-- doxytag: member="scbm_api.h::SCBM_CALLBACKROUTINE_T" ref="89cab02f4f13a1ce35e72bfcbc3ec3d2" args="(void *context, signed long read, unsigned long address, unsigned char *buffer, unsigned long num_bytes_transferred, unsigned long status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="scbm__api_8h.html#89cab02f4f13a1ce35e72bfcbc3ec3d2">SCBM_CALLBACKROUTINE_T</a>(void *context, signed long read, unsigned long address, unsigned char *buffer, unsigned long num_bytes_transferred, unsigned long status)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The callback function provides a way for the device driver/API to notify the calling application of I/O completion. The driver does not require the callback function to provide any specific function, but it must not use any MeOS functions that would require a scheduling operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*context</em>&nbsp;</td><td>Pointer to private context for the callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>read</em>&nbsp;</td><td>States whether this is read or write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Address of slave that data was transferred to/from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*buffer</em>&nbsp;</td><td>Pointer to buffer where data was transferred to/from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_bytes_transferred</em>&nbsp;</td><td>Number of bytes transferred in the transaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Status code describing the completion status of the transaction (one of SCBM_STATUS_CODES). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="feeb88107d056cc518c0a9d00c9c7713"></a><!-- doxytag: member="scbm_api.h::SCBM_PORT_T" ref="feeb88107d056cc518c0a9d00c9c7713" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structscbm__port__t.html">scbm_port_t</a>  <a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
It contains all context required by a single SCB master port. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="f93ef91be29ab3f7546c96391c18232d"></a><!-- doxytag: member="scbm_api.h::SCBM_STATUS_CODES" ref="f93ef91be29ab3f7546c96391c18232d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d">SCBM_STATUS_CODES</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These define the status codes that are returned by SCBM API functions. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="f93ef91be29ab3f7546c96391c18232df7459b895b168b03a2db55f679e5ce78"></a><!-- doxytag: member="SCBM_STATUS_SUCCESS" ref="f93ef91be29ab3f7546c96391c18232df7459b895b168b03a2db55f679e5ce78" args="" -->SCBM_STATUS_SUCCESS</em>&nbsp;</td><td>
Operation completed successfully. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f93ef91be29ab3f7546c96391c18232d1cbfa1e4cfb387f4e1cbb26dfb7a7a16"></a><!-- doxytag: member="SCBM_STATUS_INVALID_PORT" ref="f93ef91be29ab3f7546c96391c18232d1cbfa1e4cfb387f4e1cbb26dfb7a7a16" args="" -->SCBM_STATUS_INVALID_PORT</em>&nbsp;</td><td>
Invalid port number. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f93ef91be29ab3f7546c96391c18232d497c3588084c78791e6eedd01ae30b9e"></a><!-- doxytag: member="SCBM_STATUS_CANCEL" ref="f93ef91be29ab3f7546c96391c18232d497c3588084c78791e6eedd01ae30b9e" args="" -->SCBM_STATUS_CANCEL</em>&nbsp;</td><td>
Operation was cancelled. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f93ef91be29ab3f7546c96391c18232d1d3dcaaec298c7c52956b33b4f8eb5bd"></a><!-- doxytag: member="SCBM_STATUS_TIMEOUT" ref="f93ef91be29ab3f7546c96391c18232d1d3dcaaec298c7c52956b33b4f8eb5bd" args="" -->SCBM_STATUS_TIMEOUT</em>&nbsp;</td><td>
Operation timed out. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f93ef91be29ab3f7546c96391c18232d7799938cd0edc5499d470eacee3bc0a8"></a><!-- doxytag: member="SCBM_STATUS_WOULD_BLOCK" ref="f93ef91be29ab3f7546c96391c18232d7799938cd0edc5499d470eacee3bc0a8" args="" -->SCBM_STATUS_WOULD_BLOCK</em>&nbsp;</td><td>
Asynchronous I/O has been requested, but the routine would need to block. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b4eb59bbace63c8bc6ba363bd2c08ae8"></a><!-- doxytag: member="scbm_api.h::SCBMInit" ref="b4eb59bbace63c8bc6ba363bd2c08ae8" args="(SCBM_PORT_T *port, SCBM_SETTINGS_T *port_settings, SCBM_IO_BLOCK_T *io_blocks, unsigned long num_io_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SCBMInit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscbm__settings__t.html">SCBM_SETTINGS_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port_settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscbm__io__block__t.html">SCBM_IO_BLOCK_T</a> *&nbsp;</td>
          <td class="paramname"> <em>io_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>num_io_blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function is used to initialise the SCB Master. It should be called before calling <a class="el" href="scbm__api_8h.html#d9363b9364834fc86a51e5aaf98c074a">SCBMRead()</a> or <a class="el" href="scbm__api_8h.html#801e978c1173476cd83302fe1e9cd45b">SCBMWrite()</a>. It is not necessary to re-initialise the driver before subsequent calls to these functions unless any of the parameters set in this function are to be altered.<p>
The only parameter set up at the initialisation stage is the bitrate, which is stored in the <a class="el" href="scbm__api_8h.html#1d8005d36ccd6527c47c559e6e767e04" title="This structure defines the SCBM port settings.">SCBM_SETTINGS_T</a> structure, pointed to by the port_settings input argument. The number of the SCB port to be used is also required.<p>
If asynchronous operation is not required, io_blocks may be set as NULL and num_io_blocks set to zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*port_settings</em>&nbsp;</td><td>Pointer to port settings. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*io_blocks</em>&nbsp;</td><td>I/O blocks (required for asynchronous I/O). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_io_blocks</em>&nbsp;</td><td>Number of I/O blocks.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns <a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d1cbfa1e4cfb387f4e1cbb26dfb7a7a16">SCBM_STATUS_INVALID_PORT</a> if an invalid port number is specified and <a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232df7459b895b168b03a2db55f679e5ce78">SCBM_STATUS_SUCCESS</a> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="60accdf8c6b6b86d2c77b77733003d82"></a><!-- doxytag: member="scbm_api.h::SCBMDeinit" ref="60accdf8c6b6b86d2c77b77733003d82" args="(SCBM_PORT_T *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SCBMDeinit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function is used to deinitialise the API, and should be used as part of a safe system shutdown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns <a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232d1cbfa1e4cfb387f4e1cbb26dfb7a7a16">SCBM_STATUS_INVALID_PORT</a> if an invalid port number is specified and <a class="el" href="scbm__api_8h.html#f93ef91be29ab3f7546c96391c18232df7459b895b168b03a2db55f679e5ce78">SCBM_STATUS_SUCCESS</a> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d9363b9364834fc86a51e5aaf98c074a"></a><!-- doxytag: member="scbm_api.h::SCBMRead" ref="d9363b9364834fc86a51e5aaf98c074a" args="(SCBM_PORT_T *port, unsigned long address, unsigned char *buffer, unsigned long num_bytes_to_read, unsigned long *num_bytes_read, SCBM_ASYNC_T *async, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SCBMRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>num_bytes_to_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>num_bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscbm__async__t.html">SCBM_ASYNC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function is used to perform a 'read from slave' transaction. When it is called, the SCBM transmits a start condition, slave address (set using the 'address' input variable) and read R/W select bit to a slave device. The slave should respond by transmitting a series of data bytes until the SCBM ends the transaction by not acknowledging the last byte and then transmitting a stop condition.<p>
The SCB master stores the received data in incrementing memory locations, starting at the location specified in the 'buffer' input variable. (It is likely that the calling application will use an array to store the incoming data, so 'buffer' would be a pointer to the first term in this array.) The number of bytes that the SCBM receives before it ends the transaction is determined by the 'num_bytes_to_read' variable.<p>
If a non-blocking transfer is desired, an asynchronous descriptor must be provided giving the driver access to QIO resources and a user defined callback routine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Address of slave to be used (7 bit, in bits[7:1]). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*buffer</em>&nbsp;</td><td>Pointer to received data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_bytes_to_read</em>&nbsp;</td><td>Number of bytes to read from slave. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*num_bytes_read</em>&nbsp;</td><td>Updated each time a byte is successfully received, giving a count of the number of bytes read from the slave. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*async</em>&nbsp;</td><td>Pointer to asynchronous I/O descriptor if a non-blocking transfer is required (else NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Number of MeOS timer ticks before operation times out. Set to SCBM_INF_TIMEOUT for an infinite period of time.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns as follows: SCBM_STATUS_SUCCESS Operation completed successfully. SCBM_STATUS_CANCEL Operation was cancelled. SCBM_STATUS_TIMEOUT Operation timed out. SCBM_STATUS_WOULD_BLOCK Asynchronous I/O has been requested, but the routine would need to block.</dd></dl>
Note: This routine will always return successfully if asynchronous I/O is requested. 
</div>
</div><p>
<a class="anchor" name="801e978c1173476cd83302fe1e9cd45b"></a><!-- doxytag: member="scbm_api.h::SCBMWrite" ref="801e978c1173476cd83302fe1e9cd45b" args="(SCBM_PORT_T *port, unsigned long address, unsigned char *buffer, unsigned long num_bytes_to_write, unsigned long *num_bytes_written, SCBM_ASYNC_T *async, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SCBMWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>num_bytes_to_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>num_bytes_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscbm__async__t.html">SCBM_ASYNC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function is used to perform a 'write to slave' transaction. When it is called, the SCB master transmits a start condition, slave address (set using the 'address' input variable) and write R/W select bit to a slave device to begin the transaction. It then transmits 'num_bytes_to_write' data bytes from incrementing memory locations, starting at the address specified in the 'buffer' input variable. It ends the transaction by transmitting a stop condition.<p>
If a non-blocking transfer is desired, an asynchronous descriptor must be provided giving the driver access to QIO resources and a user defined callback routine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Address of slave to be used (10/7 bit addressing. For 7 bit addressing, bits [9..7] must be 0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*buffer</em>&nbsp;</td><td>Pointer to buffer containing data to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_bytes_to_write</em>&nbsp;</td><td>Number of bytes to transmit to slave. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*num_bytes_written</em>&nbsp;</td><td>Updated each time a byte is successfully transmitted, giving a count of the number of bytes written tp the slave. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*async</em>&nbsp;</td><td>Pointer to asynchronous I/O descriptor if a non-blocking transfer is required (else NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Number of MeOS timer ticks before operation times out. Set to SCBM_INF_TIMEOUT for an infinite period of time.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns as follows: SCBM_STATUS_SUCCESS Operation completed successfully. SCBM_STATUS_CANCEL Operation was cancelled. SCBM_STATUS_TIMEOUT Operation timed out. SCBM_STATUS_WOULD_BLOCK Asynchronous I/O has been requested, but the routine would need to block.</dd></dl>
Note: This routine will always return successfully if asynchronous I/O is requested. 
</div>
</div><p>
<a class="anchor" name="4788388eb4c905bd56bc075602532113"></a><!-- doxytag: member="scbm_api.h::SCBMGetResult" ref="4788388eb4c905bd56bc075602532113" args="(SCBM_PORT_T *port, signed long *read, unsigned long *address, unsigned long *num_bytes_transferred, signed long block, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SCBMGetResult           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed long *&nbsp;</td>
          <td class="paramname"> <em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>num_bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed long&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function gets the result of an asynchronous operation. It can be called after an SCBM transaction has been carried out. The function is passed the SCBM_PORT_T descriptor for the port it is retrieving the result from. It determines the slave address, transaction type (read/write) and number of bytes transferred and updates the contents of the pointers passed to it. It also returns a status code describing the way in which the transaction completed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*read</em>&nbsp;</td><td>Updated to show whether the transaction was a read (non-zero) or write (zero). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*address</em>&nbsp;</td><td>Updated with address of slave used in transaction (7 bit, in bits[7:1]). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*num_bytes_transferred</em>&nbsp;</td><td>Updated with the number of bytes transferred. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>Blocking flag. 1 to block, 0 not to block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Timeout to use when blocking. Number of MeOS timer ticks before operation times out. Set to SCBM_INF_TIMEOUT for an infinite period of time.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns as follows: SCBM_STATUS_SUCCESS Operation completed successfully. SCBM_STATUS_CANCEL Operation was cancelled. SCBM_STATUS_TIMEOUT Operation timed out. </dd></dl>

</div>
</div><p>
<a class="anchor" name="63145a5032894485f97bfbf3119bb066"></a><!-- doxytag: member="scbm_api.h::SCBMCancel" ref="63145a5032894485f97bfbf3119bb066" args="(SCBM_PORT_T *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCBMCancel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscbm__port__t.html">SCBM_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function cancels the current, and all queued asynchronous operations. The function is passed the <a class="el" href="scbm__api_8h.html#feeb88107d056cc518c0a9d00c9c7713" title="This structure describes a SCB master logical object.">SCBM_PORT_T</a> descriptor for the transaction it is cancelling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none. </dd></dl>

</div>
</div><p>
</div>
</body>
</html>
