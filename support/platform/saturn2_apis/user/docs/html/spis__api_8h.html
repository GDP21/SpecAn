<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>spis_api.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>spis_api.h File Reference</h1>Serial Peripheral Interface Slave API.  
<a href="#_details">More...</a>
<p>

<p>
<a href="spis__api_8h-source.html">Go to the source code of this file.</a><h2>Data Structures</h2>
<ul>
<li>struct <a class="el" href="structspis__port__t.html">spis_port_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the SPIS port object.  <a href="structspis__port__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structSPIS__PARAM__T.html">SPIS_PARAM_T</a>
<dl class="el"><dd class="mdescRight">This structure contains initialisation parameters.  <a href="structSPIS__PARAM__T.html#_details">More...</a><br></dl><li>struct <a class="el" href="structspis__callback__t.html">spis_callback_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the SPIS Callback type.  <a href="structspis__callback__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structspis__io__block__t.html">spis_io_block_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the SPIS I/O Block type required for asynchronous operation.  <a href="structspis__io__block__t.html#_details">More...</a><br></dl><li>struct <a class="el" href="structspis__async__t.html">spis_async_t</a>
<dl class="el"><dd class="mdescRight">This structure defines the asynchronous I/O descriptor type.  <a href="structspis__async__t.html#_details">More...</a><br></dl></ul>
<h2>Defines</h2>
<ul>
<li><a class="anchor" name="1a454723bc8a8a8fa4f295fa2c50d699"></a><!-- doxytag: member="spis_api.h::__SPIS_API_H__" ref="1a454723bc8a8a8fa4f295fa2c50d699" args="" -->
#define <b>__SPIS_API_H__</b>
<li>#define <a class="el" href="spis__api_8h.html#352e2c4e73df77ac0f4d6c8f3a677e2a">SPIS_INF_TIMEOUT</a>&nbsp;&nbsp;&nbsp;-1
<li>#define <a class="el" href="spis__api_8h.html#9b1be26ce43808bf1fa017e7baa3c91b">SPIS_ASYNC_GET_RESULT</a>(async, context)
<li>#define <a class="el" href="spis__api_8h.html#603438c7495675ab49afb9cbff881541">SPIS_ASYNC_FORGET</a>(async)
<li>#define <a class="el" href="spis__api_8h.html#b7c22639e1767e9764638fc794cc285f">SPIS_ASYNC_CALLBACK</a>(async, routine, context)
</ul>
<h2>Typedefs</h2>
<ul>
<li><a class="anchor" name="2918464223233d91a9c67a9b96dfc3ae"></a><!-- doxytag: member="spis_api.h::SPIS_PORT_T" ref="2918464223233d91a9c67a9b96dfc3ae" args="" -->
typedef struct <a class="el" href="structspis__port__t.html">spis_port_t</a> <a class="el" href="spis__api_8h.html#2918464223233d91a9c67a9b96dfc3ae">SPIS_PORT_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the SPIS port object. <br></dl><li>typedef void <a class="el" href="spis__api_8h.html#c55aa30a1fb64316205a8491851c644e">SPIS_CALLBACKROUTINE_T</a> (void *context, unsigned char *buffer, unsigned long num_bytes_to_transfer, unsigned long status)
<dl class="el"><dd class="mdescRight">This type defines the Callback Routine used by the SPIS device driver in the asynchronous transfer mode.  <a href="#c55aa30a1fb64316205a8491851c644e"></a><br></dl><li><a class="anchor" name="3fe09b73997267cc526f93d9da486b02"></a><!-- doxytag: member="spis_api.h::SPIS_CALLBACK_T" ref="3fe09b73997267cc526f93d9da486b02" args="" -->
typedef struct <a class="el" href="structspis__callback__t.html">spis_callback_t</a> <a class="el" href="spis__api_8h.html#3fe09b73997267cc526f93d9da486b02">SPIS_CALLBACK_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the SPIS Callback type. <br></dl><li><a class="anchor" name="767ccb79741d22bcdf882d6fd0ac31a5"></a><!-- doxytag: member="spis_api.h::SPIS_IO_BLOCK_T" ref="767ccb79741d22bcdf882d6fd0ac31a5" args="" -->
typedef struct <a class="el" href="structspis__io__block__t.html">spis_io_block_t</a> <a class="el" href="spis__api_8h.html#767ccb79741d22bcdf882d6fd0ac31a5">SPIS_IO_BLOCK_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the SPIS I/O Block type required for asynchronous operation. <br></dl><li><a class="anchor" name="565fa068ba2d0e62f0032a7b52e1be26"></a><!-- doxytag: member="spis_api.h::SPIS_ASYNC_T" ref="565fa068ba2d0e62f0032a7b52e1be26" args="" -->
typedef struct <a class="el" href="structspis__async__t.html">spis_async_t</a> <a class="el" href="spis__api_8h.html#565fa068ba2d0e62f0032a7b52e1be26">SPIS_ASYNC_T</a>
<dl class="el"><dd class="mdescRight">This structure defines the asynchronous I/O descriptor type. <br></dl></ul>
<h2>Enumerations</h2>
<ul>
<li>enum <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b">SPIS_RETURN_T</a> { <br>
&nbsp;&nbsp;<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0ba901236138c373d2c86fedea777e4fea">SPIS_OK</a> =  0, 
<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b86a45ff7d9571f5ed658340b7f58328e">SPIS_INVALID_DMA_CHANNELS</a>, 
<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b3e586b067688d41e633311cad6b7650a">SPIS_INVALID_SPI_MODE</a>, 
<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b8af8be651a2f42cbdf72a361cc3acb96">SPIS_INVALID_CS_ACTIVE_LEVEL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b85a6bf0c7352cf949d21da9b12fe27d7">SPIS_INVALID_SYNC_MODE</a>, 
<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b7f4a635b48d589c8e586d1aa0b8efda1">SPIS_INVALID_PIN_CONFIG</a>, 
<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b658c95d6c09260ecf39ca9aa1469de44">SPIS_STATUS_SUCCESS</a>, 
<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b1d64c774eb87ba29c562dbce5f46866d">SPIS_STATUS_CANCEL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0be8ca7e9e02047e9fa2a05be62c750c4b">SPIS_STATUS_TIMEOUT</a>, 
<a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0bc74b67a6333317f64df36ae48123cca6">SPIS_STATUS_WOULD_BLOCK</a>
<br>
 }
<li>enum <a class="el" href="spis__api_8h.html#ec2795384d9cae12ea598b00c4352d91">SPIS_MODE_T</a> { <a class="el" href="spis__api_8h.html#ec2795384d9cae12ea598b00c4352d91152359b11fb4b43ed0c5485eb0ab0673">SPI_MODE_0</a> =  0, 
<a class="el" href="spis__api_8h.html#ec2795384d9cae12ea598b00c4352d917c1990cc15e9d69621be8e0e757e634c">SPI_MODE_1</a>, 
<a class="el" href="spis__api_8h.html#ec2795384d9cae12ea598b00c4352d914d350945d895a4acdc45ae96b0b82fc3">SPI_MODE_2</a>, 
<a class="el" href="spis__api_8h.html#ec2795384d9cae12ea598b00c4352d91f06ec36087996d6f328df39866ff5de6">SPI_MODE_3</a>
 }
<li>enum <a class="el" href="spis__api_8h.html#b51ed136979c377af05038817d95d567">SPIS_SYNC_MODE_T</a> { <a class="el" href="spis__api_8h.html#b51ed136979c377af05038817d95d56790c1be39d2776a518a5db1dffa0158c8">SPI_SYNC_MODE_RESYNC</a> =  0, 
<a class="el" href="spis__api_8h.html#b51ed136979c377af05038817d95d5677b5c0cc67e21df5e78afff8c72f4a4d4">SPI_SYNC_MODE_SLOW</a>, 
<a class="el" href="spis__api_8h.html#b51ed136979c377af05038817d95d56727b1bdf74091afbf5e3ebb60402b81c5">SPI_SYNC_MODE_LEGACY</a>
 }
</ul>
<h2>Functions</h2>
<ul>
<li>img_void <a class="el" href="spis__api_8h.html#9f50c963102e0461c7b8e31f33640691">SPISDefine</a> (<a class="el" href="structioblock__sBlockDescriptorTag.html">ioblock_sBlockDescriptor</a> *psBlockDescriptor)
<li>unsigned long <a class="el" href="spis__api_8h.html#e32d3c3143710e6bc93876b98322fbe5">SPISInit</a> (<a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *port, <a class="el" href="structSPIS__PARAM__T.html">SPIS_PARAM_T</a> *initParam, <a class="el" href="structspis__io__block__t.html">SPIS_IO_BLOCK_T</a> *io_blocks, unsigned long num_io_blocks)
<li>unsigned long <a class="el" href="spis__api_8h.html#c363908a90c12dde3c247398dd29ef74">SPISRead</a> (<a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *port, unsigned char *buf, unsigned long dmaLength, <a class="el" href="structspis__async__t.html">SPIS_ASYNC_T</a> *async, long timeout)
<li>unsigned long <a class="el" href="spis__api_8h.html#29ca6e789a23a193c594b645e8f4c21f">SPISWrite</a> (<a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *port, unsigned char *buf, unsigned long dmaLength, <a class="el" href="structspis__async__t.html">SPIS_ASYNC_T</a> *async, long timeout)
<li>unsigned long <a class="el" href="spis__api_8h.html#5f31211685d235f29df25318a123c48b">SPISGetResult</a> (<a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *port, void **context, int block, long timeout)
<li>unsigned long <a class="el" href="spis__api_8h.html#638784eb6a231c708cf6cc03a8672586">SPISCancel</a> (<a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *port)
<li>img_void <a class="el" href="spis__api_8h.html#ab9b460ea50048159d87e55c2bcebdc2">SPISDeinit</a> (<a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *port)
</ul>
<h2>Variables</h2>
<ul>
<li><a class="anchor" name="a39e6dc70481d70bac2e566c18b48ec2"></a><!-- doxytag: member="spis_api.h::IMG_asSPISBlock" ref="a39e6dc70481d70bac2e566c18b48ec2" args="[]" -->
<a class="el" href="structioblock__sBlockDescriptorTag.html">ioblock_sBlockDescriptor</a> <b>IMG_asSPISBlock</b> []
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains the header file information for the Serial Peripheral Interface Slave (SPIS) API.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Imagination Technologies</dd></dl>
<b>Copyright 2006 by Imagination Technologies Limited.</b><br>
 All rights reserved. No part of this software, either material or conceptual may be copied or distributed, transmitted, transcribed, stored in a retrieval system or translated into any human or computer language in any form by any means, electronic, mechanical, manual or other-wise, or disclosed to the third parties without the express written permission of Imagination Technologies Limited, Home Park Estate, Kings Langley, Hertfordshire, WD4 8LZ, U.K. <hr><h2>Define Documentation</h2>
<a class="anchor" name="352e2c4e73df77ac0f4d6c8f3a677e2a"></a><!-- doxytag: member="spis_api.h::SPIS_INF_TIMEOUT" ref="352e2c4e73df77ac0f4d6c8f3a677e2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPIS_INF_TIMEOUT&nbsp;&nbsp;&nbsp;-1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Infinite wait (do not time out). 
</div>
</div><p>
<a class="anchor" name="9b1be26ce43808bf1fa017e7baa3c91b"></a><!-- doxytag: member="spis_api.h::SPIS_ASYNC_GET_RESULT" ref="9b1be26ce43808bf1fa017e7baa3c91b" args="(async, context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPIS_ASYNC_GET_RESULT          </td>
          <td>(</td>
          <td class="paramtype">async,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ (async)-&gt;forget = 0;                     \
      (async)-&gt;callback_context = context; }
</pre></div>Async descriptor helper macro used to get result of async operation. 
</div>
</div><p>
<a class="anchor" name="603438c7495675ab49afb9cbff881541"></a><!-- doxytag: member="spis_api.h::SPIS_ASYNC_FORGET" ref="603438c7495675ab49afb9cbff881541" args="(async)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPIS_ASYNC_FORGET          </td>
          <td>(</td>
          <td class="paramtype">async&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ (async)-&gt;forget = 1; \
      (async)-&gt;callback_routine = NULL; }
</pre></div>Async descriptor helper macro used to ignore result of async operation. 
</div>
</div><p>
<a class="anchor" name="b7c22639e1767e9764638fc794cc285f"></a><!-- doxytag: member="spis_api.h::SPIS_ASYNC_CALLBACK" ref="b7c22639e1767e9764638fc794cc285f" args="(async, routine, context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPIS_ASYNC_CALLBACK          </td>
          <td>(</td>
          <td class="paramtype">async,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">routine,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ (async)-&gt;forget = 1; \
      (async)-&gt;callback_routine = routine; \
      (async)-&gt;callback_context = context; }
</pre></div>Async descriptor helper macro used to register a callback routine to collect the result of an async operation. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="c55aa30a1fb64316205a8491851c644e"></a><!-- doxytag: member="spis_api.h::SPIS_CALLBACKROUTINE_T" ref="c55aa30a1fb64316205a8491851c644e" args="(void *context, unsigned char *buffer, unsigned long num_bytes_to_transfer, unsigned long status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="spis__api_8h.html#c55aa30a1fb64316205a8491851c644e">SPIS_CALLBACKROUTINE_T</a>(void *context, unsigned char *buffer, unsigned long num_bytes_to_transfer, unsigned long status)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The callback function provides a way for the device driver/API to notify the calling application of I/O completion. The driver does not require the callback function to provide any specific function, but it must not use any MeOS functions that would require a scheduling operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*context</em>&nbsp;</td><td>Pointer to private context for the callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*buffer</em>&nbsp;</td><td>Pointer to buffer where data was transferred to/from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_bytes_to_transfer</em>&nbsp;</td><td>The number of bytes the slave was 'expecting' to transfer (tis is the size of the buffer that data was transferred to/from) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Status code describing the completion status of the transaction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b"></a><!-- doxytag: member="spis_api.h::SPIS_RETURN_T" ref="87b06087c02f74ad0c527d5d80704f0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b">SPIS_RETURN_T</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These define the status codes that are returned by SPIS API functions. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0ba901236138c373d2c86fedea777e4fea"></a><!-- doxytag: member="SPIS_OK" ref="87b06087c02f74ad0c527d5d80704f0ba901236138c373d2c86fedea777e4fea" args="" -->SPIS_OK</em>&nbsp;</td><td>
Initialisation parameters are valid. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b86a45ff7d9571f5ed658340b7f58328e"></a><!-- doxytag: member="SPIS_INVALID_DMA_CHANNELS" ref="87b06087c02f74ad0c527d5d80704f0b86a45ff7d9571f5ed658340b7f58328e" args="" -->SPIS_INVALID_DMA_CHANNELS</em>&nbsp;</td><td>
DMA channel parameters are invalid. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b3e586b067688d41e633311cad6b7650a"></a><!-- doxytag: member="SPIS_INVALID_SPI_MODE" ref="87b06087c02f74ad0c527d5d80704f0b3e586b067688d41e633311cad6b7650a" args="" -->SPIS_INVALID_SPI_MODE</em>&nbsp;</td><td>
Mode parameter is invalid. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b8af8be651a2f42cbdf72a361cc3acb96"></a><!-- doxytag: member="SPIS_INVALID_CS_ACTIVE_LEVEL" ref="87b06087c02f74ad0c527d5d80704f0b8af8be651a2f42cbdf72a361cc3acb96" args="" -->SPIS_INVALID_CS_ACTIVE_LEVEL</em>&nbsp;</td><td>
Chip select active level is invalid. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b85a6bf0c7352cf949d21da9b12fe27d7"></a><!-- doxytag: member="SPIS_INVALID_SYNC_MODE" ref="87b06087c02f74ad0c527d5d80704f0b85a6bf0c7352cf949d21da9b12fe27d7" args="" -->SPIS_INVALID_SYNC_MODE</em>&nbsp;</td><td>
Sync mode parameter is invalid </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b7f4a635b48d589c8e586d1aa0b8efda1"></a><!-- doxytag: member="SPIS_INVALID_PIN_CONFIG" ref="87b06087c02f74ad0c527d5d80704f0b7f4a635b48d589c8e586d1aa0b8efda1" args="" -->SPIS_INVALID_PIN_CONFIG</em>&nbsp;</td><td>
Pin configuration is invalid. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b658c95d6c09260ecf39ca9aa1469de44"></a><!-- doxytag: member="SPIS_STATUS_SUCCESS" ref="87b06087c02f74ad0c527d5d80704f0b658c95d6c09260ecf39ca9aa1469de44" args="" -->SPIS_STATUS_SUCCESS</em>&nbsp;</td><td>
Operation completed successfully. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0b1d64c774eb87ba29c562dbce5f46866d"></a><!-- doxytag: member="SPIS_STATUS_CANCEL" ref="87b06087c02f74ad0c527d5d80704f0b1d64c774eb87ba29c562dbce5f46866d" args="" -->SPIS_STATUS_CANCEL</em>&nbsp;</td><td>
Operation was cancelled. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0be8ca7e9e02047e9fa2a05be62c750c4b"></a><!-- doxytag: member="SPIS_STATUS_TIMEOUT" ref="87b06087c02f74ad0c527d5d80704f0be8ca7e9e02047e9fa2a05be62c750c4b" args="" -->SPIS_STATUS_TIMEOUT</em>&nbsp;</td><td>
Operation was timed out. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="87b06087c02f74ad0c527d5d80704f0bc74b67a6333317f64df36ae48123cca6"></a><!-- doxytag: member="SPIS_STATUS_WOULD_BLOCK" ref="87b06087c02f74ad0c527d5d80704f0bc74b67a6333317f64df36ae48123cca6" args="" -->SPIS_STATUS_WOULD_BLOCK</em>&nbsp;</td><td>
Asynchronous I/O has been requested, but the routine would need to block. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec2795384d9cae12ea598b00c4352d91"></a><!-- doxytag: member="spis_api.h::SPIS_MODE_T" ref="ec2795384d9cae12ea598b00c4352d91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="spis__api_8h.html#ec2795384d9cae12ea598b00c4352d91">SPIS_MODE_T</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type defines the SPI Mode. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ec2795384d9cae12ea598b00c4352d91152359b11fb4b43ed0c5485eb0ab0673"></a><!-- doxytag: member="SPI_MODE_0" ref="ec2795384d9cae12ea598b00c4352d91152359b11fb4b43ed0c5485eb0ab0673" args="" -->SPI_MODE_0</em>&nbsp;</td><td>
Mode 0 (clock idle low, data valid on first clock transition). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ec2795384d9cae12ea598b00c4352d917c1990cc15e9d69621be8e0e757e634c"></a><!-- doxytag: member="SPI_MODE_1" ref="ec2795384d9cae12ea598b00c4352d917c1990cc15e9d69621be8e0e757e634c" args="" -->SPI_MODE_1</em>&nbsp;</td><td>
Mode 1 (clock idle low, data valid on second clock transition). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ec2795384d9cae12ea598b00c4352d914d350945d895a4acdc45ae96b0b82fc3"></a><!-- doxytag: member="SPI_MODE_2" ref="ec2795384d9cae12ea598b00c4352d914d350945d895a4acdc45ae96b0b82fc3" args="" -->SPI_MODE_2</em>&nbsp;</td><td>
Mode 2 (clock idle high, data valid on first clock transition). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ec2795384d9cae12ea598b00c4352d91f06ec36087996d6f328df39866ff5de6"></a><!-- doxytag: member="SPI_MODE_3" ref="ec2795384d9cae12ea598b00c4352d91f06ec36087996d6f328df39866ff5de6" args="" -->SPI_MODE_3</em>&nbsp;</td><td>
Mode 3 (clock idle high, data valid on second clock transition). </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="b51ed136979c377af05038817d95d567"></a><!-- doxytag: member="spis_api.h::SPIS_SYNC_MODE_T" ref="b51ed136979c377af05038817d95d567" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="spis__api_8h.html#b51ed136979c377af05038817d95d567">SPIS_SYNC_MODE_T</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This type defines the SPI synchronisation mode. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="b51ed136979c377af05038817d95d56790c1be39d2776a518a5db1dffa0158c8"></a><!-- doxytag: member="SPI_SYNC_MODE_RESYNC" ref="b51ed136979c377af05038817d95d56790c1be39d2776a518a5db1dffa0158c8" args="" -->SPI_SYNC_MODE_RESYNC</em>&nbsp;</td><td>
Resync mode. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b51ed136979c377af05038817d95d5677b5c0cc67e21df5e78afff8c72f4a4d4"></a><!-- doxytag: member="SPI_SYNC_MODE_SLOW" ref="b51ed136979c377af05038817d95d5677b5c0cc67e21df5e78afff8c72f4a4d4" args="" -->SPI_SYNC_MODE_SLOW</em>&nbsp;</td><td>
Slow Sync mode </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b51ed136979c377af05038817d95d56727b1bdf74091afbf5e3ebb60402b81c5"></a><!-- doxytag: member="SPI_SYNC_MODE_LEGACY" ref="b51ed136979c377af05038817d95d56727b1bdf74091afbf5e3ebb60402b81c5" args="" -->SPI_SYNC_MODE_LEGACY</em>&nbsp;</td><td>
Legacy mode </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="9f50c963102e0461c7b8e31f33640691"></a><!-- doxytag: member="spis_api.h::SPISDefine" ref="9f50c963102e0461c7b8e31f33640691" args="(ioblock_sBlockDescriptor *psBlockDescriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">img_void SPISDefine           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structioblock__sBlockDescriptorTag.html">ioblock_sBlockDescriptor</a> *&nbsp;</td>
          <td class="paramname"> <em>psBlockDescriptor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd></dd></dl>
This function defines an instance of a SPI Master block. 
</div>
</div><p>
<a class="anchor" name="e32d3c3143710e6bc93876b98322fbe5"></a><!-- doxytag: member="spis_api.h::SPISInit" ref="e32d3c3143710e6bc93876b98322fbe5" args="(SPIS_PORT_T *port, SPIS_PARAM_T *initParam, SPIS_IO_BLOCK_T *io_blocks, unsigned long num_io_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SPISInit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPIS__PARAM__T.html">SPIS_PARAM_T</a> *&nbsp;</td>
          <td class="paramname"> <em>initParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspis__io__block__t.html">SPIS_IO_BLOCK_T</a> *&nbsp;</td>
          <td class="paramname"> <em>io_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>num_io_blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function is used to initialise the SPI Slave. This must be done before a transaction is carried out using <a class="el" href="spis__api_8h.html#c363908a90c12dde3c247398dd29ef74">SPISRead()</a> or <a class="el" href="spis__api_8h.html#29ca6e789a23a193c594b645e8f4c21f">SPISWrite()</a>. It is not necessary to re-initialise the SPIS before further transactions unless any of the parameters set up at initialisation are to be changed.<p>
The function initialises the port by allocating a QIO device object to the SPIS port object defined by the structure SPIS_PORT_T.<p>
The parameters set up at initialisation are the SPI mode, CS active level and DMA input and output channel numbers. DMA transfers are used to transfer data from memory to the SPIS (for writes) and from the SPIS to memory (for reads). The DMA channel numbers determine which DMA channels are used.<p>
The input and output DMA channels must be different.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*initParam</em>&nbsp;</td><td>Pointer to initialisation parameters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*io_blocks</em>&nbsp;</td><td>I/O blocks (required for asynchronous I/O). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_io_blocks</em>&nbsp;</td><td>Number of I/O blocks.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>SPIS_OK if initialisation parameters are valid SPIS_INVALID_&lt;type&gt; if &lt;type&gt; parameter is not valid </dd></dl>

</div>
</div><p>
<a class="anchor" name="c363908a90c12dde3c247398dd29ef74"></a><!-- doxytag: member="spis_api.h::SPISRead" ref="c363908a90c12dde3c247398dd29ef74" args="(SPIS_PORT_T *port, unsigned char *buf, unsigned long dmaLength, SPIS_ASYNC_T *async, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SPISRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>dmaLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspis__async__t.html">SPIS_ASYNC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function is used to perform a 'read from master' transaction. When the function is called, the SPIS is made ready to receive data. The transaction from the peripheral to the outside world is controlled by the master, which sets the CS line active to start the transaction, then transmits a series of bytes on the MOSI (master out slave in) data line.<p>
A DMA transfer is used to transfer data from the peripheral to memory. The SPIS stores data in incrementing memory locations, starting at the address specified in the 'buf' parameter. Whilst the master controls when the transaction ends by controlling how much data is transmitted to the peripheral and when the CS line is disabled, the number of bytes read in by the SPISRead function is determined by the DMA transfer.<p>
If the master does not send as much data as 'dmaLength' specified, and if this mismatch is greater than 8 bytes, then the slave read operation will not complete and data buffer will be invalid. If the mismatch is less than 8 bytes, then the slave read operation will complete with a partially invalid buffer of data. If the master sends too much data, whilst the current slave read would complete correctly, subsequent reads would not be correct.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*buf</em>&nbsp;</td><td>Buffer for received data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dmaLength</em>&nbsp;</td><td>Number of bytes to be read in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*async</em>&nbsp;</td><td>Pointer to asynchronous I/O descriptor if a non-blocking transfer is required (else NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Number of MeOS timer ticks before operation times out. Set to <a class="el" href="spis__api_8h.html#352e2c4e73df77ac0f4d6c8f3a677e2a">SPIS_INF_TIMEOUT</a> for an infinite period of time. The timer starts when QIO start function is called. This parameter has the same implication for blocking and non-blocking transfers.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns as follows: <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b658c95d6c09260ecf39ca9aa1469de44">SPIS_STATUS_SUCCESS</a> Operation completed successfully. <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b1d64c774eb87ba29c562dbce5f46866d">SPIS_STATUS_CANCEL</a> Operation was cancelled. <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0be8ca7e9e02047e9fa2a05be62c750c4b">SPIS_STATUS_TIMEOUT</a> Operation timed out. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29ca6e789a23a193c594b645e8f4c21f"></a><!-- doxytag: member="spis_api.h::SPISWrite" ref="29ca6e789a23a193c594b645e8f4c21f" args="(SPIS_PORT_T *port, unsigned char *buf, unsigned long dmaLength, SPIS_ASYNC_T *async, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SPISWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>dmaLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspis__async__t.html">SPIS_ASYNC_T</a> *&nbsp;</td>
          <td class="paramname"> <em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function is used to perform a 'write to master' transaction. When the function is called, the SPIS is made ready to transmit data. The transaction from the peripheral to the outside world is controlled by the master, which sets the CS line active to start the transaction and clocks data out of the slave. When the SPIS receives this clock and CS is active, it writes data out on the MISO (master in slave out) line.<p>
A DMA transfer is used to transfer data from the peripheral to memory. Data is taken from incrementing memory locations starting at the address specified by the 'buf' input parameter. Whilst the master controls the transaction by controlling the CS and clock line, the number of bytes transmitted by the SPISWrite function is determined by the DMA transfer.<p>
The function will only complete when 'dmaLength' bytes has been transferred from the system memory to the peripheral. Once it has transferred this number of bytes, the function will complete, even if the master has not ended the transaction. If the SPIS attempts to write more data than the master has requested, then the transaction will not complete until the master has requested enough further data from the slave such that the entire slave transaction has been transferred from the system memory to the peripheral.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*buf</em>&nbsp;</td><td>Buffer of data for transmission </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dmaLength</em>&nbsp;</td><td>Number of bytes to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*async</em>&nbsp;</td><td>Pointer to asynchronous I/O descriptor if a non-blocking transfer is required (else NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Number of MeOS timer ticks before operation times out. Set to <a class="el" href="spis__api_8h.html#352e2c4e73df77ac0f4d6c8f3a677e2a">SPIS_INF_TIMEOUT</a> for an infinite period of time. The timer starts when QIO start function is called. This parameter has the same implication for blocking and non-blocking transfers.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns as follows: <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b658c95d6c09260ecf39ca9aa1469de44">SPIS_STATUS_SUCCESS</a> Operation completed successfully. <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b1d64c774eb87ba29c562dbce5f46866d">SPIS_STATUS_CANCEL</a> Operation was cancelled. <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0be8ca7e9e02047e9fa2a05be62c750c4b">SPIS_STATUS_TIMEOUT</a> Operation timed out. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f31211685d235f29df25318a123c48b"></a><!-- doxytag: member="spis_api.h::SPISGetResult" ref="5f31211685d235f29df25318a123c48b" args="(SPIS_PORT_T *port, void **context, int block, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SPISGetResult           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function gets the result of an asynchronous operation. It can be called after an SPIS transaction has been carried out. The function is passed the <a class="el" href="spis__api_8h.html#2918464223233d91a9c67a9b96dfc3ae" title="This structure defines the SPIS port object.">SPIS_PORT_T</a> descriptor for the port it is retrieving the result from. It returns a status code describing the way in which the transaction completed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>**context</em>&nbsp;</td><td>Updated with the pointer to the context of the transaction it is retrieving the result from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>Blocking flag. 1 to block, 0 not to block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Timeout to use when blocking. Number of MeOS timer ticks before operation times out. Set to <a class="el" href="spis__api_8h.html#352e2c4e73df77ac0f4d6c8f3a677e2a">SPIS_INF_TIMEOUT</a> for an infinite period of time.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This function returns as follows: <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b658c95d6c09260ecf39ca9aa1469de44">SPIS_STATUS_SUCCESS</a> Operation completed successfully. <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0b1d64c774eb87ba29c562dbce5f46866d">SPIS_STATUS_CANCEL</a> Operation was cancelled. <a class="el" href="spis__api_8h.html#87b06087c02f74ad0c527d5d80704f0be8ca7e9e02047e9fa2a05be62c750c4b">SPIS_STATUS_TIMEOUT</a> Operation timed out. </dd></dl>

</div>
</div><p>
<a class="anchor" name="638784eb6a231c708cf6cc03a8672586"></a><!-- doxytag: member="spis_api.h::SPISCancel" ref="638784eb6a231c708cf6cc03a8672586" args="(SPIS_PORT_T *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SPISCancel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function cancels ALL (active and pending) operations queued on the device. The function is passed the <a class="el" href="spis__api_8h.html#2918464223233d91a9c67a9b96dfc3ae" title="This structure defines the SPIS port object.">SPIS_PORT_T</a> descriptor for the transaction it is cancelling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab9b460ea50048159d87e55c2bcebdc2"></a><!-- doxytag: member="spis_api.h::SPISDeinit" ref="ab9b460ea50048159d87e55c2bcebdc2" args="(SPIS_PORT_T *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">img_void SPISDeinit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structspis__port__t.html">SPIS_PORT_T</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Description:</b><br>
 This function deinitialises the SPI Slave API, and should be used as part of a safe system shutdown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*port</em>&nbsp;</td><td>Pointer to port descriptor.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none. </dd></dl>

</div>
</div><p>
</div>
</body>
</html>
